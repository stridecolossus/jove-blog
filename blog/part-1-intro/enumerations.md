---
title: Enumerations
---

---

## Contents

- [Background](#background)
- [Solution](#solution)
- [Reverse Mapping](#reverse-mapping)
- [Type Conversion](#type-conversion)
- [Default Values](#default-values)

---

## Background

When first using the code generated enumerations we realised there were several requirements that had been overlooked:

1. There is also the need to map native values _to_ the corresponding enumeration constant, e.g. when retrieving the set of `VkQueueFlag` for a physical device.

2. Additionally many of the enumerations are in fact bit-fields requiring some mechanism to reduce a collection of constants to the native representation (and again to perform the reverse operation).

3. A native enumeration is implemented as an unsigned integer and was being mapped to `int` in the code generated structures and API methods (since Java has no analog of a native `typedef`).  This is obviously not type-safe, but more importantly it completely hides the actual _type_ of each field.

For a library with a handful of enumerations this would be a minor issue that could be manually implemented, but for the large number of code-generated Vulkan enumerations something more practical is required that works in __all__ cases.

## Solution

We would prefer to avoid abusing the code generator by replicating the same solution in every enumeration class (essentially a cut-and-paste bodge).  What is really needed is some sort of base-class that implements a common solution, but of course enumerations cannot be sub-classed.

However - although it is not common practice - a Java enumeration _can_ implement an interface, this technique is leveraged to define a common abstraction to support the above requirements.

> Indeed our IDE will not code-complete an interface on an enumeration presumably because it thinks it is not legal Java.

The [interface](https://github.com/stridecolossus/JOVE/blob/master/src/main/java/org/sarge/jove/util/IntEnum.java) itself is trivial and just affirms the existing `value` method of the enumerations:

```java
public interface IntEnum {
    /**
     * @return Enum literal
     */
    int value();
}
```

The enumeration template is modified to implement the new interface as illustrated in the following example:

```java
public enum VkImageUsageFlag implements IntEnum {
    TRANSFER_SRC(1),
    TRANSFER_DST(2),
    ...

    private final int value;
    
    private VkImageUsageFlag(int value) {
        this.value = value;
    }

    @Override
    public int value() {
        return value;
    }
}
```

The missing requirements can now be addressed in terms of this new type which is common to all integer enumerations.

## Reverse Mapping

The _reverse mapping_ of an integer enumeration is generated by the following new supporting class:

```java
class ReverseMapping<E extends IntEnum> {
    private final Map<Integer, E> map;

    private ReverseMapping(Class<E> clazz) {
        E[] array = clazz.getEnumConstants();
        this.map = Arrays
            .stream(array)
            .collect(toMap(IntEnum::value, Function.identity(), (a, b) -> a));
    }
}
```

Note that some enumerations have duplicate or synonymous entries (e.g. `VkImageAspect`) which are silently ignored when building the reverse mapping.

The enumeration constant for a given native value can now be looked up from the reverse mapping:

```java
public E map(int value) {
    E constant = map.get(value);
    if(constant == null) throw new IllegalArgumentException();
    return constant;
}
```

Reverse mappings are generated and cached on demand:

```java
class ReverseMapping<E extends IntEnum> {
    private static final Map<Class<?>, ReverseMapping<?>> CACHE = new ConcurrentHashMap<>();

    private static <E extends IntEnum> ReverseMapping<E> get(Class<?> clazz) {
        return (ReverseMapping<E>) CACHE.computeIfAbsent(clazz, ReverseMapping::new);
    }
}
```

Finally a public factory method is added to lookup a reverse mapping:

```java
static <E extends IntEnum> ReverseMapping<E> mapping(Class<E> clazz) {
    return ReverseMapping.get(clazz);
}
```

## Bit Masks

For enumerations that are used as bit-fields a second new type is introduced that parameterises an integer enumeration and wraps the underlying mask:

```java
public record BitMask<E extends IntEnum>(int bits) {
}
```

A custom constructor can now be implemented to reduce a collection of constants:

```java
public BitMask(Collection<E> values) {
    this(reduce(values));
}

private static int reduce(Collection<? extends IntEnum> values) {
    return values.stream().mapToInt(IntEnum::value).sum();
}
```

Transforming a mask to the corresponding enumeration constants is slightly more involved, the following method walks the bits of the mask and maps each to the corresponding constant:

```java
public Set<E> enumerate(ReverseMapping<E> reverse) {
    int range = Integer.SIZE - Integer.numberOfLeadingZeros(bits);
    return IntStream
        .range(0, range)
        .map(bit -> 1 << bit)
        .filter(value -> (value & bits) == value)
        .mapToObj(reverse::map)
        .collect(toSet());
    }
```

## Type Conversion

JNA uses _type converters_ to marshal Java types to/from their native equivalents and includes built-in converters for standard types (integer, string, pointer, etc).

To use integer enumerations in a type-safe manner in API methods and structures the following custom converter is implemented:

```java
TypeConverter CONVERTER = new TypeConverter() {
    @Override
    public Class<?> nativeType() {
        return Integer.class;
    }

    @Override
    public Object toNative(Object value, ToNativeContext context) {
        if(value instanceof IntEnum e) {
            return e.value();
        }
        else {
            return 0;
        }
    }

    @Override
    public Object fromNative(Object nativeValue, FromNativeContext context) {
        Class<?> type = context.getTargetType();
        ReverseMapping<?> mapping = ReverseMapping.get(type);
        return mapping.map(value);
    }
};
```

And a similar converter is implemented for the `BitMask` type.

The converters are registered with a global JNA _type mapper_ in the Vulkan library:

```java
public interface VulkanLibrary ... {
    TypeMapper MAPPER = mapper();

    private static TypeMapper mapper() {
        var mapper = new DefaultTypeMapper();
        mapper.addTypeConverter(IntEnum.class, IntEnum.CONVERTER);
        mapper.addTypeConverter(BitMask.class, BitMask.CONVERTER);
        ...
        return mapper;
    }
}
```

The JNA library is configured with this type mapper at instantiation-time:

```java
static VulkanLibrary create() {
    ...
    return Native.load(name, VulkanLibrary.class, Map.of(Library.OPTION_TYPE_MAPPER, MAPPER));
}
```

The only fly in the ointment is that this mapper also needs to be applied to __every__ JNA structure to enable integer enumerations and masks to be used as structure fields, therefore the following intermediate base-class is introduced for all code-generated structures:

```java
public abstract class VulkanStructure extends Structure {
    protected VulkanStructure() {
        super(MAPPER);
    }
}
```

## Default Values

A final complication when mapping from a native enumeration value is that a `null` or unspecified value (i.e. zero) may not be a valid enumeration constant.

A default value is introduced to the reverse mapping which is initialised in the constructor:

```java
class ReverseMapping<E extends IntEnum> {
    ...
    private final E def;

    private ReverseMapping(Class<E> clazz) {
        ...
        this.def = map.getOrDefault(0, array[0]);
    }
}
```

The default value is mapped from the enumeration constant represented by zero if present or is arbitrarily set to the first constant.

An invalid or unspecified native values can now be safely handled in the type converter:

```java
public Object fromNative(Object nativeValue, FromNativeContext context) {
    Class<?> type = context.getTargetType();
    ReverseMapping<?> mapping = ReverseMapping.get(type);
    if(nativeValue == null) {
        return mapping.def;
    }
    else {
        int num = (int) nativeValue;
        if(num == 0) {
            return mapping.def;
        }
        else {
            return mapping.map(num);
        }
    }
}
```

## Conclusion

In the code generator, the type mapping logic for structures is modified accordingly:

* Enumerated values are represented by the relevant integer enumeration class.

* Bit fields (identified by enumerations suffixed by `Bits`) are implemented as a `BitMask` of the enumeration.

