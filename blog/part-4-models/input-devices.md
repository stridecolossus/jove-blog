---
title: Input Devices
---

---

# Contents

- [Overview](#overview)
- [Mouse](#mouse-device)
- [Keyboard](#keyboard-device)
- [Summary](#summary)

---

# Overview

This chapter will introduce new functionality to support input event handling and implement a camera controller to better view the chalet model.

This will require the following:

* Support for GLFW event callbacks to be integrated with the new FFM based native layer.

* New JOVE framework code to configure input events and devices.

* Camera controllers.

While we could simply use GLFW directly in our application there are compelling reasons to introduce a layer of abstraction:

* The GLFW API exposes some underlying details (such as window handle pointers) that we would prefer to encapsulate if at all possible.

* Some events are implemented as callback handlers e.g. `MousePositionListener` and others as query functions, e.g. `glfwGetJoystickAxes`.

* Several of the GLFW events are essentially equivalent (e.g. keyboard keys and mouse buttons) but are implemented using different listeners and API calls.

* Traditional event callbacks violate the principle of separation of concerns by mixing application logic and the event handling code.

Therefore a simple abstraction layer will be implemented allowing event handling to be expressed in domain terms rather than GLFW callbacks, window handles, etc.

> Note that this approach is not intended to create a fancy 'pluggable' framework to support other libraries, in any case we are not intending to move away from GLFW any time soon.

The following devices will be supported initially:

* Keyboard.

* Mouse buttons.

* Mouse cursor.

* Mouse wheel.

The first cut will implement support for the keyboard and mouse, with other devices (e.g. joysticks and controllers) and window events (focus, enter/exit, etc) added as required in future chapters.

After a bit of analysis of the various GLFW callbacks the supported events can be reduced to the following categories:

* Button - keyboard and mouse buttons.

* Position - i.e. the mouse pointer.

* Axis - mouse wheel, joystick throttle, etc.

* Boolean - window events.

Button events will be treated as a special case since these are essentially _parameterised_ by an action (press, release) and by modifier keys (control, shift, etc), requiring more complex handling logic compared to the other types of event.

---

# Framework

## Callbacks

To support GLFW callbacks the following new JOVE type and companion transformer are introduced:

```java
public interface Callback {
    class CallbackTransformerFactory implements Registry.Factory<Callback> {
        private final Linker linker = Linker.nativeLinker();
        private final Registry registry;
    }
}
```

The transformer builds the _upcall stub_ for a given callback on demand:

```java
public Transformer<Callback, MemorySegment> transformer(Class<? extends Callback> type) {
    return new Transformer<>() {
        private final Method method = method(type);

        public MemorySegment marshal(Callback callback, SegmentAllocator allocator) {
            return upcall(method, callback);
        }
    };
}
```

The `Callback` interface itself unfortunately cannot be declared a `@FunctionalInterface` (since it is essentially a _marker_ interface), therefore the following code validates that a given callback declares a _single_ method:

```java
private static Method method(Class<? extends Callback> callback) {
    Method[] methods = callback.getDeclaredMethods();
    if(methods.length != 1) {
        throw new IllegalArgumentException(...);
    }
    return methods[0];
}
```

The `upcall` method builds the FFM function descriptor for the callback and method handle is reflected from the callback instance:

```java
MethodHandle handle = MethodHandles
    .lookup()
    .unreflect(method)
    .bindTo(instance);
```

Which is then linked to the native library:

```java
return linker.upcallStub(handle, descriptor, Arena.global());
```

Note that the stub is created using the global arena, otherwise the linker will fail.

> Callback stubs are generated on demand for each invocation of the `marshal` method.  This does not feel right but there is not really any  other way to interpret the FFM upcall API.

For the moment callbacks are restricted to primitives and `MemorySegment` parameters.  Further analysis and design is required to determine how best to support domain types such as structures.  This might look a bit of a cop out, but GLFW only really requires primitive parameters (except for window handles which are unused anyway).  The only other callback is the diagnostic handler which is treated as a special case for the forseeable future.

## Events

An _event_ is a simple _marker_ interface with a convenience listener abstraction that handles events:

```java
public interface Event {
    /**
     * An <i>event handler</i> processes events generated by a device.
     * @param <E> Event type
     */
    interface Handler<E extends Event> {
        /**
         * Handles the given event.
         * @param event Event
         */
        void handle(E event);
    }
}
```

Events are generated by _devices_ which can be bound to a handler to process the events:

```java
public interface Device<E extends Event> {
    /**
     * @return Whether this device is currently bound to an event handler
     */
    boolean isBound();

    /**
     * Binds an event handler to this device.
     * @param handler Event handler
     * @return Underlying callback
     * @throws IllegalStateException if this device is already bound
     */
    Callback bind(Consumer<E> handler);

    /**
     * Removes the attached event handler.
     * @throws IllegalArgumentException if this device is not bound
     */
    void remove();
}
```

## Device Template

The various GLFW devices will be implemented by the following template:

```java
abstract class AbstractWindowDevice<E extends Event, T extends Callback> implements Device<E> {
    private final Window window;
    private T callback;

    public boolean isBound() {
        return Objects.nonNull(callback);
    }
}
```

This class defines the following pair of methods that are used to manage the underlying GLFW callback:

```java
/**
 * Creates the callback for the given window and event listener.
 * @param window        Window
 * @param listener      Event listener
 * @return Callback
 */
protected abstract T callback(Window window, Consumer<E> listener);

/**
 * Provides the GLFW setter method for this device.
 * @param library Device library
 * @return Callback setter
 */
protected abstract BiConsumer<Window, T> method(DeviceLibrary library);
```

The `bind` method first invokes `callback` to create a GLFW callback instance:

```java
public T bind(Consumer<E> listener) {
    if(isBound()) {
        throw new IllegalStateException(...);
    }

    this.callback = callback(window, listener);
    ...

    return callback;
}
```

Which is then attached to the window by invoking the API method returned from `method`:

```java
BiConsumer<Window, T> method = method((DeviceLibrary) window.library());
method.accept(window, callback);
```

The callback is detached similarly:

```java
public void remove() {
    if(!isBound()) {
        throw new IllegalStateException(...);
    }

    BiConsumer<Window, T> method = method((DeviceLibrary) window.library());
    method.accept(window, null);

    this.callback = null;
}
```

The `callback` is a mutable class member, both ensuring that only one callback is ever registered at any one time, and preventing listeners from being garbage collected, since they are otherwise out of scope after binding.  Note that GLFW automatically removes callbacks that are no longer active.

---

# Mouse Device

## Mouse Wheel

With a basic event handling framework in place we can now create specific implementations to support the basic GLFW devices, the mouse scroll wheel is probably the simplest device and is tackled first.

Events generated by the mouse wheel are essentially a floating-point increment:

```java
public record AxisEvent(float value) implements Event {
}
```

This event type will also be used later for other 'axis' devices such as a joystick throttle.

The mouse wheel device specifies the type of event, the callback, and the API setter method:

```java
public class MouseWheel extends AbstractWindowDevice<AxisEvent, MouseListener> {
    MouseWheel(Window window) {
        super(window);
    }

    protected BiConsumer<Window, MouseListener> method(DeviceLibrary library) {
        return library::glfwSetScrollCallback;
    }
}
```

The `callback` is essentially an adapter that extracts the wheel increment (the Y value in this case) from the GLFW callback and delegates the event to the handler:

```java
protected MouseListener callback(Window window, Consumer<AxisEvent> listener) {
    return new MouseListener() {
        public void event(MemorySegment window, double x, double y) {
            listener.accept(new AxisEvent((int) y));
        }
    };
}
```

Finally the relevant API method and callback signature are defined in the GLFW library:

```java
interface DeviceLibrary {
    @FunctionalInterface
    interface MouseListener extends Callback {
        /**
         * Notifies a mouse event.
         * @param window    Window
         * @param x         X coordinate
         * @param y         Y coordinate
         */
        void event(MemorySegment window, double x, double y);
    }

    /**
     * Registers a mouse scroll listener.
     * @param window        Window
     * @param listener      Mouse scroll listener
     */
    void glfwSetScrollCallback(Window window, MouseListener listener);
}
```

## Mouse Pointer

The second event category required by the mouse device is a _screen coordinate_ representing an X-Y window position:

```java
public record ScreenCoordinate(int x, int y) implements Event {
}
```

The implementation of the pointer device follows the same pattern as above:

```java
public class MousePointer extends AbstractWindowDevice<ScreenCoordinate, MouseListener> {
    protected MouseListener callback(Window window, Consumer<ScreenCoordinate> listener) {
        return new MouseListener() {
            @Override
            public void event(MemorySegment window, double x, double y) {
                var pos = new ScreenCoordinate((int) x, (int) y);
                listener.accept(pos);
            }
        };
    }

    protected BiConsumer<Window, MouseListener> method(DeviceLibrary library) {
        return library::glfwSetCursorPosCallback;
    }
}
```

Note that the same callback interface is used for both the mouse wheel and pointer since the signature is the same in both cases.

## Integration

The mouse devices are aggregated and added to the window class:

```java
public class Window extends AbstractNativeObject {
    public record Mouse(MousePointer pointer, MouseWheel wheel) {
    }

    private final Mouse mouse = new Mouse(new MousePointer(this), new MouseWheel(this));
}
```

The demo application can now attach listeners to dump events generated by these devices to the console:

```java
@Configuration
class Control {
    @Autowired
    void mouse(Window window) {
        Mouse mouse = window.mouse();
        mouse.pointer().bind(System.out::println);
        mouse.wheel().bind(System.out::println);
    }
}
```

Note that the application still depends on a GLFW polling loop running on the main thread to generate events:

```java
@Bean
static CommandLineRunner poll(Desktop desktop) {
    return _ -> {
        while(true) {
            desktop.poll();
            Thread.sleep(50);
        }
    };
}
```

---

# Keyboard Device


---

## Summary

This chapter covered the implementation of:

* A simple event handling framework that abstracts over the underlying GLFW library.

* The action bindings class that aids separation of concerns for input events and application action handlers.

* Free-look and orbital camera controllers.

